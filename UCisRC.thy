theory UCisRC  imports    HOL.Realbeginsection "Requirements for UC-style compositionality"datatype ('color) prgm = Prgrm 'colordatatype ('color) ctxt = Ctxt 'colordatatype ('color) whle = Whle 'colorpartial_function (tailrec) oddity :: "nat => nat"where "oddity arg = (case arg of (Suc (Suc n)) => n | 0 => 0 )"consts   call:: "'blue prgm \<Rightarrow> 'red prgm \<Rightarrow> 'blue prgm" (infixr "\<circ>\<circ>"  60)  bigcall:: "'blue whle \<Rightarrow> 'red whle \<Rightarrow> 'blue whle" (infixr "\<circ>\<circ>\<circ>" 52)  par:: "'blue ctxt \<Rightarrow> 'red ctxt \<Rightarrow> 'blue ctxt" (infixl "\<parallel>" 60)  link:: "'b ctxt \<Rightarrow> 'b prgm \<Rightarrow> 'b whle" (infixl "><" 55)   ple :: "'c whle \<Rightarrow> 'd whle \<Rightarrow> bool" (infixl "\<lesssim>" 50)abbreviation RRgen:: "('r whle \<Rightarrow> 'b whle \<Rightarrow> bool) \<Rightarrow> 'r prgm \<Rightarrow> 'b prgm \<Rightarrow> bool"   where  "RRgen rel (p::'r prgm) (f::'b prgm) \<equiv>     \<forall> (A::'r ctxt). \<exists> (S::'b ctxt). rel (A >< p) (S >< f)"abbreviation RR:: "'r prgm \<Rightarrow> 'b prgm \<Rightarrow> bool" ("_ robustly-refines _" [20,20] 17)  where  "RR p f \<equiv> RRgen ple p f"locale composition =  assumes par_decomp: (* parallel decomposition (for pink programs using red programs) *)  "\<forall> (A::'p ctxt) (P1::'p prgm) (P2::'r prgm) .             \<exists> (A1::'p ctxt) (A2::'r ctxt).      A >< P1 \<circ>\<circ> P2 \<lesssim> A1 \<parallel> A2 >< P1 \<circ>\<circ> P2"  and inter_comp: (* intertwined composition (dito) *)  "\<forall> (P1::'p prgm) (P2::'r prgm)               (A1::'p ctxt) (A2::'r ctxt).       A1 \<parallel> A2 >< P1 \<circ>\<circ> P2 \<lesssim> A1 >< P1 \<circ>\<circ>\<circ> A2 >< P2"  and inter_decomp: (* intertwined composition (for pink programs using blue programs) *)  "\<forall> (P1::'p prgm) (P2::'b prgm) A1 A2 .    A1 >< P1 \<circ>\<circ>\<circ> A2 >< P2  \<lesssim>   A1 \<parallel> A2 >< P1 \<circ>\<circ> P2 "  and  const_elim: (* constant elimination (for plugging substituting red with blue in pink contexts*)  "\<forall> (redW::'r whle) (blueW::'b whle) (pinkW::'p whle) .       ( (redW \<lesssim> blueW) \<longrightarrow> ( pinkW \<circ>\<circ>\<circ> redW \<lesssim> pinkW \<circ>\<circ>\<circ> blueW))"  and transitivity [simp,trans]: (* transitivity of trace relation for pink programs *)  "(W1::'p whle) \<lesssim> (W2::'p whle)    \<Longrightarrow>  W2 \<lesssim> (W3::'p whle)  \<Longrightarrow> W1 \<lesssim> W3"(* new axioms for dummy adversary theorem *)locale dummy = (* dummy context and program *) fixes Pd::"'r prgm" (* Z\<rightarrow>Pd \<Rightarrow> Z\<rightarrow>Psub, A\<rightarrow>Pd\<Rightarrow> undefined  , Psub\<rightarrow>Pd\<Rightarrow> Psub\<Rightarrow>Z, *) fixes Ad::"'r ctxt" (* Z\<rightarrow>Ad \<Rightarrow> Z\<rightarrow>P,    P\<rightarrow> Ad \<Rightarrow> P\<rightarrow>Z *) assumes adv_split: "\<forall> A (P::'r prgm) . \<exists> A' . A >< Pd\<circ>\<circ>P \<lesssim> (A' \<parallel> Ad) >< Pd\<circ>\<circ>P"  and prog_unsplit:  "\<forall>(A::'r ctxt) (P::'b prgm) . \<exists> (A'::'b ctxt) . A >< (Pd \<circ>\<circ> P) \<lesssim> A' >< P"   and prog_split: "\<forall>(A::'r ctxt) (P::'r prgm) . \<exists> (A'::'r ctxt) . A >< P \<lesssim>  A' >< (Pd \<circ>\<circ> P)"   and  const_elim2: (* constant elimination for red contexts *) "\<forall>(redW::'r whle) (blueW::'b whle) (W::'r whle) .       ( (redW \<lesssim> blueW) \<longrightarrow> ( W \<circ>\<circ>\<circ> redW \<lesssim> W \<circ>\<circ>\<circ> blueW))" and inter_comp2: (* intertwined composition (for red  programs) *) "\<forall>(P1::'r prgm) (P2::'r prgm)               (A1::'r ctxt) (A2::'r ctxt).       A1 \<parallel> A2 >< P1 \<circ>\<circ> P2 \<lesssim> A1 >< P1 \<circ>\<circ>\<circ> A2 >< P2" and inter_decomp2: (* intertwined composition (for pink programs using blue programs) *) "\<forall> (P1::'r prgm) (P2::'b prgm) A1 A2.    A1 >< P1 \<circ>\<circ>\<circ> A2 >< P2  \<lesssim>  A1 \<parallel> A2 >< P1 \<circ>\<circ> P2 " and transitivity2 [trans]: (* transitivity of trace relation for red programs *) "\<lbrakk>(W1::'r whle) \<lesssim> (W2::'r whle); W2 \<lesssim> (W3::'r whle)\<rbrakk> \<Longrightarrow> W1 \<lesssim> W3" and transitivity3 [trans]: (* transitivity of trace relation from red-to-red to red-to-blue  *) "\<lbrakk>(W1'::'r whle) \<lesssim> (W2'::'r whle); W2' \<lesssim> (W3'::'b whle)\<rbrakk> \<Longrightarrow> W1' \<lesssim> W3'" context dummybegintheorem dummy:  fixes P::"'r prgm"  fixes F::"'b prgm"  assumes A: " \<exists> (S::'b ctxt) . Ad >< P \<lesssim> S >< F"shows "\<forall> (A::'r ctxt). \<exists> (S::'b ctxt) . A >< P \<lesssim> S >< F"proof  fix A   from prog_split obtain A' where "A >< P \<lesssim> A' >< (Pd \<circ>\<circ> P)" by auto  also obtain  A'' where "... \<lesssim> A'' \<parallel> Ad >< Pd \<circ>\<circ> P" using adv_split by auto   also have "... \<lesssim> (A'' >< Pd) \<circ>\<circ>\<circ> (Ad >< P)" using inter_comp2 by blast  also obtain S where "... \<lesssim> (A'' >< Pd) \<circ>\<circ>\<circ> (S >< F)" using A const_elim2 by blast  also have "... \<lesssim> ((A'' \<parallel> S) >< (Pd \<circ>\<circ> F))" using inter_decomp2 by blast  also obtain S' where "... \<lesssim> S' >< F" using prog_unsplit by blast  finally have Almost:"A >< P \<lesssim> S' >< F".  thus "\<exists> (S::'b ctxt) . A >< P \<lesssim> S >< F" by auto qedendcontext compositionbegintheorem composition:  fixes P::"'r prgm"  fixes F::"'b prgm"  fixes R::"'p prgm"  assumes A: "P robustly-refines F"  shows "R \<circ>\<circ> P robustly-refines R \<circ>\<circ> F"proof  fix A  from par_decomp obtain A1 A2 where "(A >< R \<circ>\<circ> P) \<lesssim> ((A1::'p ctxt) \<parallel> (A2:: 'r ctxt) >< R \<circ>\<circ> P)" by presburger  also have  "... \<lesssim>  (A1 >< R \<circ>\<circ>\<circ> A2 >< P)" by (simp add:inter_comp)  finally have OK:"(A >< R \<circ>\<circ> P) \<lesssim>  (A1 >< R \<circ>\<circ>\<circ> A2 >< P)".    from A obtain S2 where "(A2 >< P) \<lesssim> (S2 >< F)" by auto  hence "(A1 >< R) \<circ>\<circ>\<circ> (A2 >< P) \<lesssim> (A1 >< R) \<circ>\<circ>\<circ> (S2 >< F)" by (simp add:const_elim)  also have "... \<lesssim> (A1 \<parallel> S2) >< (R \<circ>\<circ> F)" by (simp add:inter_decomp)  finally have  "(A1 >< R) \<circ>\<circ>\<circ> (A2 >< P) \<lesssim> (A1 \<parallel> S2) >< (R \<circ>\<circ> F)".  from this OK have "(A >< R \<circ>\<circ> P) \<lesssim> (A1 \<parallel> S2) >< (R \<circ>\<circ> F)" by (meson transitivity)     then show "\<exists> S . (A >< R \<circ>\<circ> P) \<lesssim> S >< (R \<circ>\<circ> F)" by metisqedendsection "Relating UC to RSCP"type_synonym ('b,'r) comp = "'b prgm \<Rightarrow> 'r prgm"consts       leadsto :: "'a whle \<Rightarrow> 't \<Rightarrow> bool" (infixr "\<leadsto>" 51)       prefix :: "'t \<Rightarrow> bool"(* We instantiate RSCHP from RRgen above for modularity. *)abbreviation RSCHPrel  where  "RSCHPrel (t:: 't itself) W W' \<equiv> (\<forall> m :: 't . prefix m \<longrightarrow>  W \<leadsto> m \<longrightarrow>  W' \<leadsto> m)"abbreviation RSCHP  where  "RSCHP C (t:: 't itself) \<equiv> \<forall> P . RRgen (RSCHPrel (t:: 't itself)) (C P) P"locale UC =   fixes PrExec  :: "'env \<Rightarrow> 'uc ctxt \<Rightarrow> 'uc prgm \<Rightarrow> bool \<Rightarrow> real"  fixes PrExecT :: "'env \<Rightarrow> 'uc ctxt \<Rightarrow> 'uc prgm \<Rightarrow> 't \<Rightarrow> real"    (* Note: PrExec and PrExecT are total function. Hence, when the random vars Exec or ExecT are       undefined, we give them probability zero.  *)  fixes \<beta> :: "'t \<Rightarrow> bool" (* extracts final bit from trace *)   fixes Zcan :: "'t \<Rightarrow> 'env" (* canonical Z: produces messages to A and P as specified by t *)  fixes nonprobabilistic :: "'env \<Rightarrow> bool"    (* assumptions needed in both directions *)  assumes relation_uc: (* We can define a semantic's from UC's semantics. *)    "prefix t \<longrightarrow>  (A >< P) \<leadsto> (t,p) \<equiv> (PrExecT (Zcan t) A P t) = p \<and> p > 0"  and prefix_iff_trace_is_prefix: (* PL-level trace (i.e., tuple) is prefix is the UC trace in it is. *)    "prefix (t::'t,p::real) \<equiv> prefix t"  (* only needed in RSCHPtoUC *)  and prefixes_contain_final_bit: (* every finite trace contains the final bit *)    "PrExec Z A P b = (\<Sum> t \<in> {t. prefix t \<and> \<beta> t = b}  . PrExecT Z A P t)"  and nonprobabilistic_envs_are_complete:    "(\<exists> Z b. PrExec Z A P b \<noteq> PrExec Z S F b) \<longrightarrow> (\<exists> Z' . PrExec Z' A P True \<noteq> PrExec Z' S F True \<and> nonprobabilistic Z')"    and construct_canonical_env:    "\<lbrakk>nonprobabilistic Z;  prefix t; (\<exists> A' P' . PrExecT Z A' P' t > 0) \<rbrakk> \<Longrightarrow> PrExecT Z A P t = PrExecT (Zcan t) A P t"  (* only needed in UCtoRSCHP *)  and construct_canonical_env2:    "\<lbrakk>prefix t \<rbrakk> \<Longrightarrow> PrExecT (Zcan t) A P t = PrExec (Zcan t) A P True"  (* axioms of probabilities *)  and unit_interval: "PrExec Z A P True = 1- PrExec Z A P False"  and unit_interval_min: "PrExec Z A P b \<ge> 0"  and PrExecT_unit_interval_min: "PrExecT Z A P t \<ge> 0"context UCbeginabbreviation UCemulates:: "'uc prgm \<Rightarrow> 'uc prgm \<Rightarrow> bool" (infixl "UC-emulates" 45)  where  "UCemulates P F \<equiv> \<forall> A . \<exists> (S::'uc ctxt) . \<forall> (Z::'env).     (PrExec Z A P True = PrExec Z S F True)"lemma UCemulates_reflexive:  fixes P::"'uc prgm"  shows "P UC-emulates P"  by metislemma difference_in_sum' :  fixes f:: "'a \<Rightarrow> real"  fixes g:: "'a \<Rightarrow> real"  assumes A:" (\<Sum> x\<in> P . f x) > (\<Sum>x \<in> P . g x)"  shows "\<exists> x\<in>P . f x > g x "proof (rule ccontr)  assume CF: "\<not>(\<exists> x\<in>P . f x > g x)"  then show "False"   proof -    from CF have "\<forall> x\<in> P.  f x \<le>  g x" by auto    hence "\<forall>x.  (x\<in>P \<longrightarrow> f x \<le> g x)" by simp    from this sum_mono have "(\<Sum>x\<in>P. f x) \<le> (\<Sum>x\<in>P. g x)" by metis    thus "False" using A by arith   qedqedlemma distinguishingZ_differentTrace:  assumes A: "PrExecT Z A P t \<noteq> PrExecT Z S F t"  and  B: "PrExecT Z A P t > 0"  and Z : "nonprobabilistic Z"  and T : "prefix t"  shows "\<exists> p ::real .(A >< P) \<leadsto> (t,p) \<and> \<not>((S >< F) \<leadsto> (t,p))"proof -  from B have t_possible_in_Z: "\<exists> A' P' . PrExecT Z A' P' t > 0" by auto  from Z construct_canonical_env A T t_possible_in_Z have A':"PrExecT (Zcan t) A P t \<noteq> PrExecT (Zcan t) S F t" by fastforce  from Z construct_canonical_env B T have B': "PrExecT (Zcan t) A P t > 0" by fastforce  let ?p = "PrExecT (Zcan t) A P t"  from relation_uc B' have Yes: "(A >< P) \<leadsto> (t,?p)" by blast  have No: "\<not>((S >< F) \<leadsto> (t,?p))"  proof (rule ccontr)    assume C:"\<not>\<not>(S >< F) \<leadsto> (t,?p)"    show "False"    proof -      from C relation_uc T have "(PrExecT (Zcan t) S F t) = ?p \<and> ?p > 0" by metis      hence "PrExecT (Zcan t) S F t = ?p" by auto      from this A' show "False" by simp    qed  qed  from Yes No show ?thesis by autoqedlemma greater_to_unequal_and_nonzero:  assumes Greater: "PrExecT Z A P t > PrExecT Z S F t"  shows "PrExecT Z A P t \<noteq> PrExecT Z S F t \<and> PrExecT Z A P t > 0"proof -  from PrExecT_unit_interval_min have "PrExecT Z S F t \<ge>  0" by simp  from this Greater have B:"PrExecT Z A P t > 0" by fastforce   from this Greater show ?thesis by autoqedlemma PrExec_bit_selects_inequality:  assumes "PrExec Z A P True \<noteq> PrExec Z' A' P' True"  shows "\<exists> b. PrExec Z A P b > PrExec Z' A' P' b"proof -  consider         (A) "PrExec Z A P True > PrExec Z' A' P' True"       | (B) "PrExec Z A P True < PrExec Z' A' P' True"     using assms by fastforce   then show ?thesis   proof cases    case A then show ?thesis by auto  next    case B then show ?thesis using unit_interval by auto  qedqedtheorem RSCHPtoUC':  fixes C ::"('uc,'uc) comp"  fixes ttype :: "('t \<times> real) itself"  fixes P::"'uc prgm"  assumes A: "\<forall> A:: 'uc ctxt . \<exists> S::'uc ctxt.                 \<forall> (m:: ('t \<times> real)). prefix m \<longrightarrow>  A >< C P \<leadsto> m \<longrightarrow> S >< P \<leadsto> m"  shows " (C P) UC-emulates P"proof (rule ccontr)  assume CF: "\<not> C P UC-emulates P"  then show "False"   proof -     from CF obtain A::"'uc ctxt" where CF1:"\<forall> (S::'uc ctxt) . \<exists> (Z::'env).       PrExec Z A (C P) True \<noteq> PrExec Z S P True" by auto    from A obtain S::"'uc ctxt" where      A1: "\<forall> (m:: ('t \<times> real)). prefix m \<longrightarrow>  A >< C P \<leadsto> m \<longrightarrow> S >< P \<leadsto> m" by blast    from CF1 have "\<exists> Z . PrExec Z A (C P) True \<noteq> PrExec Z S P True"      by auto    hence        "\<exists> Z . PrExec Z A (C P) True \<noteq> PrExec Z S P True \<and> nonprobabilistic Z"       using nonprobabilistic_envs_are_complete by metis    then obtain Z::"'env"       where "PrExec Z A (C P) True \<noteq> PrExec Z S P True"      and Prob: "nonprobabilistic Z"      by auto    (* Need to select a bit here so that one is larger than the other.*)    then obtain b::"bool" where "PrExec Z A (C P) b > PrExec Z S P b"        using PrExec_bit_selects_inequality by metis      hence "(\<Sum> t\<in> {t. prefix t \<and> \<beta> t= b} .         PrExecT Z A (C P) t) > (\<Sum> t\<in>{t . prefix t \<and> \<beta> t = b} . PrExecT Z S P t)"       using prefixes_contain_final_bit by simp    then obtain t::"'t"         where "PrExecT Z A (C P) t > PrExecT Z S P t"        and Prefix: "prefix t" using difference_in_sum' by fastforce    then have "PrExecT Z A (C P) t \<noteq> PrExecT Z S P t"         and  "PrExecT Z A (C P) t > 0"         using greater_to_unequal_and_nonzero by auto    then obtain p::"real" where "A >< (C P) \<leadsto> (t,p) \<and> \<not>((S >< P) \<leadsto> (t,p)) "         using Prob Prefix distinguishingZ_differentTrace by metis    moreover have "prefix (t,p)" using Prefix prefix_iff_trace_is_prefix by auto    ultimately show False using A1 by fastforceqed qedtheorem RSCHPtoUC:  fixes C ::"('uc,'uc) comp"  fixes ttype :: "('t \<times> real) itself"  assumes A: "RSCHP C ttype"  shows "\<forall> (P::'uc prgm) . (C P) UC-emulates P"using RSCHPtoUC' assms by presburgertheorem UCtoRSCHP:  fixes C ::"('uc,'uc) comp"  fixes ttype :: "('t \<times> real) itself"  assumes A1: "\<forall> (P::'uc prgm) . (C P) UC-emulates P"  shows "RSCHP C ttype"proof (rule ccontr)  assume CF: "\<not> (RSCHP C ttype)"  then show "False"   proof -    from CF obtain P A where  NotRSCHP: "\<forall> (S::'uc ctxt).      (\<exists> m :: ('t \<times> real) . prefix m \<and> (A >< (C P) \<leadsto> m) \<and> \<not>(S >< P \<leadsto> m))" by auto    from A1 obtain S where Eq: "\<forall> (Z::'env) . (PrExec Z A (C P) True = PrExec Z S P True)" by blast    from NotRSCHP have      "(\<exists>  (t::'t) (p::real) . prefix (t,p) \<and> (A >< (C P) \<leadsto> (t,p)) \<and> \<not>(S >< P \<leadsto> (t,p)))"      by auto     then obtain  t :: "'t" and p :: "real"      where prefix_full: "prefix (t,p)"       and Yes:"A >< (C P) \<leadsto> (t,p)"      and No: "\<not>(S >< P \<leadsto> (t,p))" by auto    from prefix_full prefix_iff_trace_is_prefix have prefix: "prefix t" by simp    let ?Z = "Zcan t"    from Yes relation_uc prefix have PrEx1: "PrExecT ?Z A (C P) t = p" by metis    from Yes relation_uc prefix have p_nonzero: "p> 0" by metis    from PrEx1 prefix construct_canonical_env2  prefix       have LHS: "PrExec ?Z A (C P) True = p" by auto        from No relation_uc p_nonzero prefix have "p \<noteq> PrExecT ?Z S P t" by blast    moreover have "PrExecT ?Z S P t = PrExec ?Z S P True"      using construct_canonical_env2 prefix   by simp    ultimately have RHS: "PrExec ?Z S P True \<noteq> p" by simp    from LHS RHS  have "PrExec ?Z A (C P) True \<noteq> PrExec ?Z S P True" by arith    from this Eq show "False" by blast  qedqedendsection "Relating UC to RHP"abbreviation RHPrel  where  "RHPrel (t:: 't itself) W W' \<equiv>         (\<forall> m :: 't . prefix m \<longrightarrow>  (W \<leadsto> m \<longleftrightarrow> W' \<leadsto> m))"abbreviation RHP  where  "RHP C (t:: 't itself) \<equiv> \<forall> P . RRgen (RHPrel (t:: 't itself)) (C P) P"context UC begintheorem RHPtoUC:  fixes C ::"('uc,'uc) comp"  fixes ttype :: "('t \<times> real) itself"  assumes A: "RHP C ttype"  shows "\<forall> (P::'uc prgm) . (C P) UC-emulates P"using RSCHPtoUC assms by blasttheorem UCtoRHP:  fixes C ::"('uc,'uc) comp"  fixes ttype :: "('t \<times> real) itself"  assumes A1: "\<forall> (P::'uc prgm) . (C P) UC-emulates P"  shows "RHP C ttype"proof (rule ccontr)  assume CF: "\<not> (RHP C ttype)"  then show "False"   proof -    from CF obtain P A where  NotRSCHP: "\<forall> (S::'uc ctxt).      (\<exists> m :: ('t \<times> real) . prefix m \<and>  (A >< (C P) \<leadsto> m) \<noteq> (S >< P \<leadsto> m))" by auto    from A1 obtain S where Eq: "\<forall> (Z::'env) . (PrExec Z A (C P) True = PrExec Z S P True)" by blast    from NotRSCHP have "(\<exists>  (t::'t) (p::real) . prefix (t,p) \<and> ((A >< (C P) \<leadsto> (t,p)) \<noteq> (S >< P \<leadsto> (t,p))))" by auto     then obtain  t :: "'t" and p :: "real" and AY and AN and PY and PN      where prefix_full: "prefix (t,p)"       and Yes:"AY >< PY \<leadsto> (t,p)"      and No: "\<not>(AN >< PN \<leadsto> (t,p))"      and Dunno: "(AY  = A \<and> PY = C P \<and> AN = S \<and> PN = P)                 \<or>(AN  = A \<and> PN = C P \<and> AY = S \<and> PY = P)"      by metis    from prefix_full prefix_iff_trace_is_prefix have prefix: "prefix t" by simp    let ?Z = "Zcan t"    from Yes relation_uc prefix have PrEx1: "PrExecT ?Z AY PY t = p" by metis    from Yes relation_uc prefix have p_nonzero: "p> 0" by metis    from PrEx1 prefix construct_canonical_env2  prefix       have LHS: "PrExec ?Z AY PY True = p" by auto        from No relation_uc p_nonzero prefix have "p \<noteq> PrExecT ?Z AN PN t" by blast    moreover have "PrExecT ?Z AN PN t = PrExec ?Z AN PN True"      using construct_canonical_env2 prefix   by simp    ultimately have RHS: "PrExec ?Z AN PN True \<noteq> p" by simp    from LHS RHS  have "PrExec ?Z AY PY True \<noteq> PrExec ?Z AN PN True" by arith    from this Eq Dunno show "False" by fastforce   qedqedendsection "Translating UC results to programming languages"lemma RRGen_is_transitive [simp,trans]:  fixes P1::"('b) prgm"  fixes P2::"('i) prgm"  fixes P3::"('r) prgm"  assumes trans: "\<forall> a b c . rel12 a b \<and> rel23 b c \<longrightarrow> rel13 a c"  assumes A: "RRgen rel12 P1 P2"  assumes B: "RRgen rel23 P2 P3" shows  "RRgen rel13 P1 P3"proof  fix A  from A obtain S2 where R1: "rel12 (A >< P1) (S2 >< P2)" by auto  from B obtain S3 where R2: "rel23 (S2 >< P2) (S3 >< P3)" by auto  from R1 R2 trans have R3: "rel13 (A >< P1) (S3 >< P3)" by simp  then show  "\<exists> S. rel13 (A >< P1) (S >< P3)" by autoqed(* First, we need transitivity for RSCHPrel. *)lemma RHPrel [simp,trans]:  fixes ttype :: "('t \<times> real) itself"   assumes A1:"RHPrel ttype a b"  assumes A2:"RHPrel ttype b c"  shows "RHPrel ttype a c"using A1 A2 by blast   context UCbegintheorem implementUC:   fixes UCC::"('uc,'uc) comp" (* This can be seen as one for more UC results. *)  fixes C1 ::"('b ,'uc) comp"    fixes C2 ::"('uc,'r ) comp"    fixes ttype :: "('t \<times> real) itself"    assumes AUCC: "\<forall> (P::'uc prgm) . (UCC P) UC-emulates P"  assumes AC1:  "RHP C1 ttype"  assumes AC2:  "RHP C2 ttype"  shows "RHP (C2 \<circ> UCC \<circ> C1) ttype"using UCtoRHP AUCC AC1 AC2   by (metis comp_apply) endabbreviation program_agree  where"program_agree P1 P2 ttype \<equiv> \<exists> C . (C P1) = P2 \<and> RHP C ttype"theorem (in UC) UCcompiler1:  fixes ttype :: "('t \<times> real) itself"    fixes Pb::"'b prgm"  fixes Pr::"'r prgm"  fixes pi::"'uc prgm"  fixes F ::"'uc prgm"    assumes AA1: "program_agree Pb F ttype"  assumes AA2: "program_agree pi Pr ttype"  fixes C:: "('b,'r) comp"  assumes AC1: "C Pb = Pr"  assumes AC2: "\<forall> P::'b prgm . P = Pb" (* Functions in Isabelle are total hence the compiler cannot error out.    We model the compiler in Thm 4 as a function from a type 'b that    covers only the programs that the compiler accepts. As Pb is the only    program the compiler accepts, the type just contains this program.*)  (* Direction \<Longrightarrow> *)  assumes AUCC': "pi UC-emulates F"  shows "RHP C ttype"proof -  fix P A   obtain C1 where C1agree: "(C1 Pb) = F" and                  C1RHP: "RHP C1 ttype" using AA1 by blast    obtain C2 where C2agree: "(C2 pi) = Pr" and                  C2RHP: "RHP C2 ttype" using AA2 by blast  define UCC where "UCC \<equiv> \<lambda>x ::'uc prgm . if x = F then pi::'uc prgm else x"    have AUCC:"\<forall> (P::'uc prgm) . (UCC P) UC-emulates P" using AUCC' UCemulates_reflexive UCC_def by auto  have RHP: "RHP (C2 \<circ> UCC \<circ> C1) ttype" using        implementUC AUCC C1RHP C2RHP     by blast  have "C = (C2 \<circ> UCC \<circ> C1)"  proof    fix x    have "x = Pb" using AC2 by simp    then show "C x = (C2 \<circ> UCC \<circ> C1) x" using AC1 C1agree UCC_def C2agree by simp  qed  then have "RHP C ttype"  using RHP by blast  then show ?thesis by blast  qedlemma (in UC) noUCnoRHP:  fixes ttype :: "('t \<times> real) itself"    assumes A1: "\<not> (C F) UC-emulates F"  shows "\<not> RHP C ttype"using A1 RHPtoUC by blast theorem (in UC) UCcompiler2:  fixes ttype :: "('t \<times> real) itself"    fixes Pb::"'b prgm"  fixes Pr::"'r prgm"  fixes pi::"'uc prgm"  fixes F ::"'uc prgm"    assumes AA2: "program_agree pi Pr ttype"  assumes AA3: "program_agree F Pb ttype"  assumes AA4: "program_agree Pr pi ttype"  fixes C:: "('b,'r) comp"  assumes AC1: "C Pb = Pr"  (* Direction \<Longrightarrow> *)  assumes ARHP: "RHP C ttype"  shows "pi UC-emulates F"proof(rule ccontr)  assume notUC: "\<not> pi UC-emulates F"  then show False  proof-  obtain C1b where C1bagree: "(C1b F) = Pb" and                  C1bRHP: "RHP C1b ttype" using AA3 by blast  obtain C2 where C2agree: "(C2 pi) = Pr" and                  C2RHP: "RHP C2 ttype" using AA2 by blast  obtain C2b where C2bagree: "(C2b Pr) = pi" and                  C2bRHP: "RHP C2b ttype" using AA4 by blast  define UCC where "UCC \<equiv> \<lambda>x ::'uc prgm . if x = F then pi::'uc prgm else x"  from notUC UCC_def have "\<not> (UCC F) UC-emulates F" by presburger  from this RSCHPtoUC' obtain A where  " \<forall> S . \<exists>m::'t \<times> real.               prefix m \<and>                A >< UCC F \<leadsto>m  \<noteq>  S >< F \<leadsto> m" by metis  from this UCC_def obtain A where  " \<forall> S . \<exists>m::'t \<times> real.               prefix m \<and>                A >< pi \<leadsto>m  \<noteq>  S >< F \<leadsto> m" by metis  from this C2RHP  obtain Cr where  "\<forall> S . \<exists>m::'t \<times> real.               prefix m \<and>                Cr >< Pr \<leadsto> m  \<noteq>  S >< F \<leadsto> m"  by (metis C2bRHP C2bagree)  hence NoSim: "\<forall> S . \<exists>m::'t \<times> real.               prefix m \<and>                Cr >< Pr \<leadsto> m  \<noteq>  S >< F \<leadsto> m" using C2agree by blast  from ARHP AC1 obtain Cb where     Bla1:"\<forall> m::'t \<times> real. prefix m \<longrightarrow> Cr >< Pr \<leadsto> m = Cb >< Pb \<leadsto> m" by blast  from C1bRHP C1bagree obtain S where     Bla2:"\<forall> m::'t \<times> real. prefix m \<longrightarrow> S >< F \<leadsto> m = Cb >< Pb \<leadsto> m" by blast  from NoSim obtain m::"'t \<times> real" where "prefix m"       and "Cr >< Pr \<leadsto> m  \<noteq>  S >< F \<leadsto> m"  by blast  from this Bla1 Bla2 show "False" by blastqedqedend